# Driver model that generates throttle and brake commands from speed reference and actual speed
component Driver
  # Input: reference speed
  speed_ref = RealInput() [{"Dyad": {"placement": {"icon": {"x1": -50, "y1": 200, "x2": 50, "y2": 300}}}}]
  # Input: actual speed
  speed_act = RealInput() [{"Dyad": {"placement": {"icon": {"x1": -50, "y1": 700, "x2": 50, "y2": 800}}}}]
  # Output: throttle command (0-1)
  throttle = RealOutput() [{"Dyad": {"placement": {"icon": {"x1": 950, "y1": 700, "x2": 1050, "y2": 800}}}}]
  # Output: brake command (0-1)
  brake = RealOutput() [{"Dyad": {"placement": {"icon": {"x1": 950, "y1": 200, "x2": 1050, "y2": 300}}}}]

  # Proportional gain for PID
  parameter k::Real = 0.5
  # Integral time constant for PID
  parameter Ti::Real = 2
  # Derivative time constant for PID
  parameter Td::Real = 0.1
  
  # Single PID controller with symmetric output range
  speed_pid = BlockComponents.LimPID(
    k = k,
    Ti = Ti,
    Td = Td,
    y_max = 1.0,
    y_min = -1.0,
    wp = 1.0,
    wd = 0.0,
    Ni = 0.9,
    Nd = 10.0,
    k_ff = 0.0
  )
  
  # Feed-forward input (not used)
  ff_input = BlockComponents.Constant(k = 0.0)
  
relations
  # Connect PID inputs
  connect(speed_ref, speed_pid.u_s)
  connect(speed_act, speed_pid.u_m)
  connect(ff_input.y, speed_pid.u_ff)
  
  # Split PID output into throttle and brake
  # Positive output -> throttle, negative output -> brake
  throttle = ifelse(speed_pid.y > 0, speed_pid.y, 0)
  brake = ifelse(speed_pid.y < 0, -speed_pid.y, 0)
metadata {"Dyad": {"icons": {"default": "dyad://FrictionBrakeDemo//driver.svg"}}}
end

# TEST HARNESS - Step response test
test component TestDriver_Constant
  # Step input for reference speed: 0 m/s to 20 m/s at t=1s
  speed_ref_source = BlockComponents.Step(
    height = 20.0,
    offset = 0.0,
    start_time = 1.0
  )
  
  # Simulated vehicle dynamics: simple first-order response
  # Acceleration = (throttle - brake) * max_accel - drag
  variable vehicle_speed::Real
  parameter max_accel::Real = 5.0  # m/s^2
  parameter drag_coeff::Real = 0.2  # drag coefficient
  
  # Driver model
  driver = Driver()
  
relations
  # Vehicle dynamics: simple model
  # acceleration = (throttle - brake) * max_accel - drag * speed
  der(vehicle_speed) = (driver.throttle - driver.brake) * max_accel - drag_coeff * vehicle_speed
  initial vehicle_speed = 0.0
  
  # Connect driver inputs directly
  connect(speed_ref_source.y, driver.speed_ref)
  driver.speed_act = vehicle_speed
end

analysis TestDriverAnalysis_Constant
  extends TransientAnalysis(stop = 10.0)
  model = TestDriver_Constant
end

# TEST HARNESS - Speed up and slow down to test both throttle and brake
test component TestDriverWithBraking
  # Multi-step reference: 0 -> 25 -> 10 m/s
  step1 = BlockComponents.Step(
    height = 25.0,
    offset = 0.0,
    start_time = 1.0
  )
  
  step2 = BlockComponents.Step(
    height = -15.0,
    offset = 0.0,
    start_time = 6.0
  )
  
  sum_steps = BlockComponents.Add()
  
  # Simulated vehicle dynamics
  variable vehicle_speed::Real
  parameter max_accel::Real = 5.0  # m/s^2
  parameter drag_coeff::Real = 0.2  # drag coefficient
  
  # Driver model
  driver = Driver()
  
relations
  # Combine steps to create speed profile: 0 -> 25 at t=1s, then 25 -> 10 at t=6s
  connect(step1.y, sum_steps.u1)
  connect(step2.y, sum_steps.u2)
  
  # Vehicle dynamics
  der(vehicle_speed) = (driver.throttle - driver.brake) * max_accel - drag_coeff * vehicle_speed
  initial vehicle_speed = 0.0
  
  # Connect driver
  connect(sum_steps.y, driver.speed_ref)
  driver.speed_act = vehicle_speed
end

analysis TestDriverAnalysis_Braking
  extends TransientAnalysis(stop = 12.0)
  model = TestDriverWithBraking()
end
