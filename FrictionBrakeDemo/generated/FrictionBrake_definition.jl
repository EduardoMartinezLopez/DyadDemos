### DO NOT EDIT THIS FILE
### This file is auto-generated by the Dyad command-line compiler.
### If you edit this code it is likely to get overwritten.
### Instead, update the Dyad source code and regenerate this file


@doc Markdown.doc"""
   FrictionBrake(; name, R_effective, N_surfaces, N_wheels, F_normal_max, μ_0, α_T, T_ref, f_partition)

## Parameters: 

| Name         | Description                         | Units  |   Default value |
| ------------ | ----------------------------------- | ------ | --------------- |
| `R_effective`         |                          | m  |   0.15 |
| `N_surfaces`         |                          | --  |   2 |
| `N_wheels`         |                          | --  |   4 |
| `F_normal_max`         |                          | N  |   5000 |
| `μ_0`         |                          | --  |   0.4 |
| `α_T`         |                          | --  |   0.0005 |
| `T_ref`         |                          | K  |   293.15 |
| `f_partition`         |                          | --  |   0.6 |

## Connectors

 * `shaft` - This connector represents a rotational spline with angle and torque as the potential and flow variables, respectively. ([`Spline`](@ref))
 * `disk` - This connector represents a thermal node with temperature and heat flow as the potential and flow variables, respectively. ([`Node`](@ref))
 * `pad` - This connector represents a thermal node with temperature and heat flow as the potential and flow variables, respectively. ([`Node`](@ref))
 * `brake_command` - This connector represents a real signal as an input to a component ([`RealInput`](@ref))

## Variables

| Name         | Description                         | Units  | 
| ------------ | ----------------------------------- | ------ | 
| `F_normal`         |                          | N  | 
| `T_interface`         |                          | K  | 
| `μ`         |                          | --  | 
| `T_brake_single_surface`         |                          | N.m  | 
| `T_brake_per_wheel`         |                          | N.m  | 
| `T_brake_magnitude`         |                          | N.m  | 
| `P_friction_total`         |                          | W  | 
| `ω`         |                          | rad/s  | 
"""
@component function FrictionBrake(; name, R_effective=0.15, N_surfaces=2, N_wheels=4, F_normal_max=5000, μ_0=0.4, α_T=0.0005, T_ref=293.15, f_partition=0.6)
  __params = Any[]
  __vars = Any[]
  __systems = System[]
  __guesses = Dict()
  __defaults = Dict()
  __initialization_eqs = []
  __eqs = Equation[]

  ### Symbolic Parameters
  append!(__params, @parameters (R_effective::Real = R_effective))
  append!(__params, @parameters (N_surfaces::Int = N_surfaces))
  append!(__params, @parameters (N_wheels::Int = N_wheels))
  append!(__params, @parameters (F_normal_max::Real = F_normal_max))
  append!(__params, @parameters (μ_0::Real = μ_0))
  append!(__params, @parameters (α_T::Real = α_T))
  append!(__params, @parameters (T_ref::Real = T_ref))
  append!(__params, @parameters (f_partition::Real = f_partition))

  ### Variables
  append!(__vars, @variables (brake_command(t)::Real), [input = true])
  append!(__vars, @variables (F_normal(t)::Real))
  append!(__vars, @variables (T_interface(t)::Real))
  append!(__vars, @variables (μ(t)::Real))
  append!(__vars, @variables (T_brake_single_surface(t)::Real))
  append!(__vars, @variables (T_brake_per_wheel(t)::Real))
  append!(__vars, @variables (T_brake_magnitude(t)::Real))
  append!(__vars, @variables (P_friction_total(t)::Real))
  append!(__vars, @variables (ω(t)::Real))

  ### Constants
  __constants = Any[]

  ### Components
  push!(__systems, @named shaft = __Dyad__Spline())
  push!(__systems, @named disk = __Dyad__Node())
  push!(__systems, @named pad = __Dyad__Node())

  ### Guesses

  ### Defaults

  ### Initialization Equations

  ### Assertions
  __assertions = []

  ### Equations
  push!(__eqs, ω ~ ModelingToolkit.D_nounits(shaft.phi))
  push!(__eqs, F_normal ~ brake_command * F_normal_max)
  push!(__eqs, T_interface ~ (disk.T + pad.T) / 2)
  push!(__eqs, μ ~ μ_0 * (1 - α_T * (T_interface - T_ref)))
  push!(__eqs, T_brake_single_surface ~ μ * F_normal * R_effective)
  push!(__eqs, T_brake_per_wheel ~ T_brake_single_surface * N_surfaces)
  push!(__eqs, T_brake_magnitude ~ T_brake_per_wheel * N_wheels)
  push!(__eqs, P_friction_total ~ T_brake_magnitude * abs(ω))
  push!(__eqs, shaft.tau ~ sign(ω) * T_brake_magnitude)
  push!(__eqs, disk.Q ~ -f_partition * P_friction_total / N_wheels)
  push!(__eqs, pad.Q ~ -(1 - f_partition) * P_friction_total / N_wheels)

  # Return completely constructed System
  return System(__eqs, t, __vars, __params; systems=__systems, defaults=__defaults, guesses=__guesses, name, initialization_eqs=__initialization_eqs, assertions=__assertions)
end
export FrictionBrake
