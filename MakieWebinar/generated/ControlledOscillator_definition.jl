### DO NOT EDIT THIS FILE
### This file is auto-generated by the Dyad command-line compiler.
### If you edit this code it is likely to get overwritten.
### Instead, update the Dyad source code and regenerate this file


@doc Markdown.doc"""
   ControlledOscillator(; name, pid_k, pid_Ti, pid_Td, pid_y_max, pid_y_min)

Undamped spring-mass oscillator with PID damping control.
The system oscillates without natural damping, and the PID controller
can apply damping force to suppress oscillations.

## Parameters: 

| Name         | Description                         | Units  |   Default value |
| ------------ | ----------------------------------- | ------ | --------------- |
| `pid_k`         | PID proportional gain                         | --  |   10 |
| `pid_Ti`         | PID integral time                         | --  |   10 |
| `pid_Td`         | PID derivative time                         | --  |   0.5 |
| `pid_y_max`         | Maximum control force                         | --  |   50 |
| `pid_y_min`         | Minimum control force                         | --  |   -50 |
"""
@component function ControlledOscillator(; name, pid_k=10, pid_Ti=10, pid_Td=0.5, pid_y_max=50, pid_y_min=-50)
  __params = Any[]
  __vars = Any[]
  __systems = System[]
  __guesses = Dict()
  __defaults = Dict()
  __initialization_eqs = []
  __eqs = Equation[]

  ### Symbolic Parameters
  append!(__params, @parameters (pid_k::Real = pid_k), [description = "PID proportional gain"])
  append!(__params, @parameters (pid_Ti::Real = pid_Ti), [description = "PID integral time"])
  append!(__params, @parameters (pid_Td::Real = pid_Td), [description = "PID derivative time"])
  append!(__params, @parameters (pid_y_max::Real = pid_y_max), [description = "Maximum control force"])
  append!(__params, @parameters (pid_y_min::Real = pid_y_min), [description = "Minimum control force"])

  ### Variables

  ### Constants
  __constants = Any[]

  ### Components
  push!(__systems, @named mass = TranslationalComponents.Mass(m=1))
  push!(__systems, @named spring = TranslationalComponents.Spring(c=100, s_rel0=0))
  push!(__systems, @named fixed = TranslationalComponents.Fixed(s0=0))
  push!(__systems, @named pid = BlockComponents.LimPID(k=pid_k, Ti=pid_Ti, Td=pid_Td, y_max=pid_y_max, y_min=pid_y_min))
  push!(__systems, @named setpoint = BlockComponents.Constant(k=0))
  push!(__systems, @named velocity_sensor = TranslationalComponents.SpeedSensor())
  push!(__systems, @named control_force = TranslationalComponents.Force())
  push!(__systems, @named ground = TranslationalComponents.Fixed(s0=0))
  push!(__systems, @named ff_input = BlockComponents.Constant(k=0))

  ### Guesses

  ### Defaults
  __defaults[mass.s] = (0.5)
  __defaults[mass.v] = (0)

  ### Initialization Equations

  ### Assertions
  __assertions = []

  ### Equations
  push!(__eqs, connect(fixed.flange, spring.flange_a))
  push!(__eqs, connect(spring.flange_b, mass.flange_a))
  push!(__eqs, connect(velocity_sensor.flange, mass.flange_a))
  push!(__eqs, connect(ground.flange, control_force.flange_a))
  push!(__eqs, connect(control_force.flange_b, mass.flange_b))
  push!(__eqs, connect(setpoint.y, pid.u_s))
  push!(__eqs, connect(velocity_sensor.v, pid.u_m))
  push!(__eqs, connect(pid.y, control_force.f))
  push!(__eqs, connect(ff_input.y, pid.u_ff))

  # Return completely constructed System
  return System(__eqs, t, __vars, __params; systems=__systems, defaults=__defaults, guesses=__guesses, name, initialization_eqs=__initialization_eqs, assertions=__assertions)
end
export ControlledOscillator
