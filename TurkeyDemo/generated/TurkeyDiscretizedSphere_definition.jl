### DO NOT EDIT THIS FILE
### This file is auto-generated by the Dyad command-line compiler.
### If you edit this code it is likely to get overwritten.
### Instead, update the Dyad source code and regenerate this file


@doc Markdown.doc"""
   TurkeyDiscretizedSphere(; name, N, Np1, M, rho, cp, k, T_init, pi, R, dr)

## Parameters: 

| Name         | Description                         | Units  |   Default value |
| ------------ | ----------------------------------- | ------ | --------------- |
| `N`         |                          | --  |   10 |
| `Np1`         |                          | --  |   N + 1 |
| `M`         |                          | kg  |   5 |
| `rho`         |                          | kg/m3  |   1050 |
| `cp`         |                          | J/(kg.K)  |   3500 |
| `k`         |                          | W/(m.K)  |   0.5 |
| `T_init`         |                          | K  |   277 |
| `pi`         |                          | --  |   3.14159265359 |
| `R`         |                          | m  |   (3 * M / (4 * pi * rho)) ^ (1 / 3) |
| `dr`         |                          | m  |   R / N |

## Connectors

 * `surface` - This connector represents a thermal node with temperature and heat flow as the potential and flow variables, respectively. ([`Node`](@ref))

## Variables

| Name         | Description                         | Units  | 
| ------------ | ----------------------------------- | ------ | 
| `T`         |                          | K  | 
| `Q_cond`         |                          | W  | 
| `r`         |                          | m  | 
| `r_mid`         |                          | m  | 
| `A_interface`         |                          | m2  | 
| `V_shell`         |                          | m3  | 
| `m_shell`         |                          | kg  | 
| `T_degF`         |                          | --  | 
"""
@component function TurkeyDiscretizedSphere(; name, N=10, Np1=N + 1, M=5, rho=1050, cp=3500, k=0.5, T_init=277, pi=3.14159265359, R=(3 * M / (4 * pi * rho)) ^ (1 / 3), dr=R / N)
  __params = Any[]
  __vars = Any[]
  __systems = System[]
  __guesses = Dict()
  __defaults = Dict()
  __initialization_eqs = []
  __eqs = Equation[]

  ### Symbolic Parameters
  append!(__params, @parameters (M::Real = M))
  append!(__params, @parameters (rho::Real = rho))
  append!(__params, @parameters (cp::Real = cp))
  append!(__params, @parameters (k::Real = k))
  append!(__params, @parameters (T_init::Real = T_init))
  append!(__params, @parameters (pi::Real = pi))
  append!(__params, @parameters (R::Real = R))
  append!(__params, @parameters (dr::Real = dr))

  ### Variables
  append!(__vars, @variables (T(t)[1:N]::Real))
  append!(__vars, @variables (Q_cond(t)[1:Np1]::Real))
  append!(__vars, @variables (r(t)[1:Np1]::Real))
  append!(__vars, @variables (r_mid(t)[1:N]::Real))
  append!(__vars, @variables (A_interface(t)[1:Np1]::Real))
  append!(__vars, @variables (V_shell(t)[1:N]::Real))
  append!(__vars, @variables (m_shell(t)[1:N]::Real))
  append!(__vars, @variables (T_degF(t)[1:N]::Real))

  ### Constants
  __constants = Any[]

  ### Components
  push!(__systems, @named surface = __Dyad__Node())

  ### Guesses

  ### Defaults

  ### Initialization Equations

  ### Assertions
  __assertions = []

  ### Equations
  push!(__eqs, A_interface[Np1] ~ 4 * pi * r[Np1] ^ 2)
  push!(__eqs, Q_cond[1] ~ 0)
  push!(__eqs, Q_cond[Np1] ~ k * A_interface[Np1] * (T[N - 1] - T[N]) / dr)
  push!(__eqs, m_shell[1] * cp * ModelingToolkit.D_nounits(T[1]) ~ Q_cond[1] - Q_cond[2])
  push!(__eqs, m_shell[N] * cp * ModelingToolkit.D_nounits(T[N]) ~ Q_cond[N] + surface.Q)
  push!(__eqs, surface.T ~ T[N])

  ### Control Structures
  for i in 1:Np1
      push!(__eqs, r[i] ~ (i - 1) * dr)
  end
  for i in 1:N
      push!(__eqs, r_mid[i] ~ (r[i] + r[i + 1]) / 2)
      push!(__eqs, A_interface[i] ~ 4 * pi * r[i] ^ 2)
      push!(__eqs, V_shell[i] ~ (4 / 3) * pi * (r[i + 1] ^ 3 - r[i] ^ 3))
      push!(__eqs, m_shell[i] ~ rho * V_shell[i])
  end
  for i in 2:N
      push!(__eqs, Q_cond[i] ~ k * A_interface[i] * (T[i - 1] - T[i]) / dr)
  end
  for i in 2:(N - 1)
      push!(__eqs, m_shell[i] * cp * ModelingToolkit.D_nounits(T[i]) ~ Q_cond[i] - Q_cond[i + 1])
  end
  for i in 1:N
      __defaults[T[i]] = (T_init)
  end
  for i in 1:N
      push!(__eqs, T_degF[i] ~ KelvinToFahrenheit(T[i]))
  end

  # Return completely constructed System
  return System(__eqs, t, __vars, __params; systems=__systems, defaults=__defaults, guesses=__guesses, name, initialization_eqs=__initialization_eqs, assertions=__assertions)
end
export TurkeyDiscretizedSphere
