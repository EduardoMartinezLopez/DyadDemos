### DO NOT EDIT THIS FILE
### This file is auto-generated by the Dyad command-line compiler.
### If you edit this code it is likely to get overwritten.
### Instead, update the Dyad source code and regenerate this file


@doc Markdown.doc"""
   ThermalHouseControlled(; name, T_initial, k_p, T_i, Q_max)

Thermal model of a house with controlled heater and input for temperature setpoint and solar irradiance

## Parameters: 

| Name         | Description                         | Units  |   Default value |
| ------------ | ----------------------------------- | ------ | --------------- |
| `T_initial`         | Initial temperature 21.1°C                         | K  |   294.26 |
| `k_p`         | Proportional gain (W/K)                         | --  |   10000 |
| `T_i`         | Integral time constant (s)                         | s  |   600 |
| `Q_max`         | Maximum heater capacity (W)                         | W  |   10000 |

## Connectors

 * `T_setpoint` - This connector represents a real signal as an input to a component ([`RealInput`](@ref))
 * `T_interior` - This connector represents a real signal as an output from a component ([`RealOutput`](@ref))
 * `Q_heater` - This connector represents a real signal as an output from a component ([`RealOutput`](@ref))
 * `solar_irradiance` - This connector represents a real signal as an input to a component ([`RealInput`](@ref))
 * `T_ambient` - This connector represents a real signal as an input to a component ([`RealInput`](@ref))
"""
@component function ThermalHouseControlled(; name, T_initial=294.26, k_p=10000, T_i=600, Q_max=10000)
  __params = Any[]
  __vars = Any[]
  __systems = System[]
  __guesses = Dict()
  __defaults = Dict()
  __initialization_eqs = []
  __eqs = Equation[]

  ### Symbolic Parameters
  append!(__params, @parameters (T_initial::Real = T_initial), [description = "Initial temperature 21.1°C"])
  append!(__params, @parameters (k_p::Real = k_p), [description = "Proportional gain (W/K)"])
  append!(__params, @parameters (T_i::Real = T_i), [description = "Integral time constant (s)"])
  append!(__params, @parameters (Q_max::Real = Q_max), [description = "Maximum heater capacity (W)"])

  ### Variables
  append!(__vars, @variables (T_setpoint(t)::Real), [input = true])
  append!(__vars, @variables (T_interior(t)::Real), [output = true])
  append!(__vars, @variables (Q_heater(t)::Real), [output = true])
  append!(__vars, @variables (solar_irradiance(t)::Real), [input = true])
  append!(__vars, @variables (T_ambient(t)::Real), [input = true])

  ### Constants
  __constants = Any[]

  ### Components
  push!(__systems, @named house = ThermalHouseDemo.ThermalHouse(T_initial=T_initial))
  push!(__systems, @named pid = BlockComponents.LimPID(k=k_p, Ti=T_i, Td=0, y_max=Q_max, y_min=0))
  push!(__systems, @named zero_ff = BlockComponents.Constant(k=0))
  push!(__systems, @named add = BlockComponents.Add())
  push!(__systems, @named cosine = BlockComponents.Cosine())
  push!(__systems, @named cosine2 = BlockComponents.Cosine())

  ### Guesses

  ### Defaults

  ### Initialization Equations

  ### Assertions
  __assertions = []

  ### Equations
  # Connect setpoint and measurement to PID
  push!(__eqs, connect(T_setpoint, pid.u_s))
  push!(__eqs, connect(house.T_interior, pid.u_m))
  push!(__eqs, connect(zero_ff.y, pid.u_ff))
  # Connect PID output to heater
  push!(__eqs, connect(pid.y, house.Q_heater))
  # Connect external inputs
  push!(__eqs, connect(solar_irradiance, house.solar_irradiance))
  push!(__eqs, connect(T_ambient, house.T_ambient))
  # Connect outputs
  push!(__eqs, connect(T_interior, house.T_interior))
  push!(__eqs, connect(Q_heater, pid.y))

  # Return completely constructed System
  return System(__eqs, t, __vars, __params; systems=__systems, defaults=__defaults, guesses=__guesses, name, initialization_eqs=__initialization_eqs, assertions=__assertions)
end
export ThermalHouseControlled
